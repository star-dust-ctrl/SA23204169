---
title: "Homework-2023.11.6"
author: "Huiyang Peng"
date: "2023-11-6"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Homework-2023.11.6}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```

# Supplementary question

## Restate

考虑模型$P(Y=1|X_1,X_2,X_3)=\frac{exp(a+b_1X_1+b_2X_2+b_3X_3)}{1+exp(a+b_1X_1+b_2X_2+b_3X_3)}$，其中$X_1\sim P(1), X_2\sim Exp(1), X_3\sim B(1,0.5)$。

(1)设计一个函数，输入$N, b_1, b_2, b_3, f_0$，生成输出$a$。

(2)调用函数，令$N=10^6, b_1=0, b_2=1,b_3=-1,f_0=0.1,0.01,0.001,0.0001$。

(3)画图：$-logf_0$ vs $a$。

## Code

```{r}
# the solve function
eva.a <- function(N, b1, b2, b3, f0){
  set.seed(0)
  x1 <- rpois(N, 1)
  x2 <- rexp(N, 1)
  x3 <- sample(c(1,0),size = N, replace = TRUE)
  f <- function(a, x1, x2, x3, f0){
    temp = exp(a+b1*x1+b2*x2+b3*x3)
    return(mean(1/(1+temp))-f0)
  }
  return(uniroot(f, interval = c(-10,10), x1, x2, x3, f0)$root)
}
```

```{r}
# call the function
N = 1e6; b1 = 0; b2=1; b3=-1; f=c(0.1,0.01,0.001,0.0001);
a = numeric(4)
for (i in 1:4) {
  a[i] <- eva.a(N, b1, b2, b3, f[i])
}
```

```{r, fig.height=5, fig.width=5}
### draw the picture
neglogf <- -log(f)
plot(neglogf, a, type="o")
```

# Exercise 9.4

## Restate

实现一个生成标准Laplace分布的随机游走Metropolis抽样，对于增量，从正态分布中生成。比较当建议分布的方差取不同值时所生成的链，并计算各个链的接受率。

## Prepare

标准Laplace分布：$f(x)=\frac{1}{2}e^{-|x|}$，建议分布取$N(X_t, \sigma^2)$。

## Code

```{r}
dlaplace <- function(x){
  return(1/2*exp(-abs(x)))
}

# Laplace chain
laplace.Metropolis <- function(sigma, x0, N){
  set.seed(0)
  x <- numeric(N)
  x[1] <- x0
  U <- runif(N)
  k <- 0
  for (i in 2:N) {
    y <- rnorm(1, x[i-1], sigma)
    if (U[i] <= dlaplace(y)/dlaplace(x[i-1])){
      x[i] <- y
    }else{
      x[i] <- x[i-1]
      k <- k + 1
    }
  }
  return(list(x=x, k=k))
}
```

```{r}
# Generate chain
N <- 2000
sigma <- c(.05, .5, 2, 16)
x0 <- 25
mc1 <- laplace.Metropolis(sigma[1], x0, N)
mc2 <- laplace.Metropolis(sigma[2], x0, N)
mc3 <- laplace.Metropolis(sigma[3], x0, N)
mc4 <- laplace.Metropolis(sigma[4], x0, N)
```

```{r, fig.height=5, fig.width=5}
# Plot chain
par(mfrow = c(2,2))
mc <- cbind(mc1$x, mc2$x, mc3$x, mc4$x)
for (j in 1:4) {
  plot(mc[,j], type = "l",
       xlab = bquote(sigma == .(round(sigma[j],3))),
       ylab = "X", ylim = range(mc[,j]))
}
par(mfrow = c(1,1))
```

```{r}
# print acceptance rate
print(1-c(mc1$k, mc2$k, mc3$k, mc4$k)/N)
```

从收敛情况来看，$\sigma=0.05$时链没有收敛，其他情况下都收敛了，其中$\sigma=2$与$\sigma=16$时收敛状况较好。建议分布的方差越低接受率越高。

# Exercise 9.7

用Gibbs采样实现一个生成二元正态链$(X_t,Y_t)$，具有零均值，单位标准差，相关系数0.9。画出丢去合适量的预烧值之后的生成样本。用这些样本拟合简单线性模型$Y=\beta_0+\beta_1 X$并检查残差的正态性和等方差性。

```{r, fig.height=5, fig.width=5}
#initialize
N <- 5000 
burn <- 1000 
X <- matrix(0, N, 2) #the chain, a bivariate sample
rho <- 0.9 #correlation
mu1 <- 0
mu2 <- 0
sigma1 <- 1
sigma2 <- 1
s1 <- sqrt(1-rho^2)*sigma1
s2 <- sqrt(1-rho^2)*sigma2

X[1, ] <- c(mu1, mu2)
for (i in 2:N) {
  x2 <- X[i-1, 2]
  m1 <- mu1 + rho * (x2 - mu2) * sigma1/sigma2
  X[i, 1] <- rnorm(1, m1, s1)
  x1 <- X[i, 1]
  m2 <- mu2 + rho * (x1 - mu1) * sigma2/sigma1
  X[i, 2] <- rnorm(1, m2, s2)
}
b <- burn + 1
x <- X[b:N, ]
plot(x, main="", cex=.5, xlab=bquote(X[1]),
ylab=bquote(X[2]), ylim=range(x[,2]))
```

```{r, fig.height=5, fig.width=5}
lr = lm(x[,2]~x[,1])
barplot(lr$residuals, space = 0)
```

可以看出残差分布是正态、等方差的。

# Exercise 9.10

用Gelman-Rubin法监控Example 9.1中链的收敛情况，模拟链直到链已经大致收敛到目标分布根据$\hat{R}<1.2$。另外，用`coda`包通过Gelman-Rubin法检查链的收敛性。Hints: `coda`中的函数gelman.diag,gelman.plot, as.mcmc, mcmc.list。

## Code

```{r, fig.height=5, fig.width=5}
# check with manual code
Gelman.Rubin <- function(psi) {
  psi <- as.matrix(psi)
  n <- ncol(psi)
  k <- nrow(psi)
  psi.means <- rowMeans(psi)
  B <- n * var(psi.means) 
  psi.w <- apply(psi, 1, "var") 
  W <- mean(psi.w) 
  v.hat <- W*(n-1)/n + (B/n) 
  r.hat <- v.hat / W 
  return(r.hat)
}

f <- function(x, sigma) {
  if (any(x < 0)) return (0)
  stopifnot(sigma > 0)
  return((x / sigma^2) * exp(-x^2 / (2*sigma^2)))
}

gen.chain <- function(x0, N, sigma){
  set.seed(0)
  x = numeric(N)
  x[1] <- x0
  k <- 0
  u = runif(N)
  for (i in 2:N) {
    xt = x[i-1]
    y = rchisq(1, df=xt)
    if(u[i] <= (f(y,sigma)*dchisq(xt, df=y))/(f(xt,sigma)*dchisq(y,df=xt))){
      x[i] = y
      k <- k + 1
    }else{
      x[i] = xt
    }
  }
  return(list(x=x, k=k))
}


N <- 1e4
sigma <- 4
b <- 1e3
x0 <- c(1,2,4,8)
chains <- matrix(0, nrow = 4, ncol = N)
for (i in 1:4) {
  chains[i,] <- gen.chain(x0[i], N, sigma)$x
}
psi = t(apply(chains, 1, cumsum))
for (i in 1:nrow(psi)){
  psi[i,] <- psi[i,] / (1:ncol(psi))
}
rhat <- rep(0, N)
for (j in (b+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[(b+1):N], type="l", xlab="", ylab="R")
abline(h=1.2, lty=2)
```

```{r, fig.height=5, fig.width=5}
# check with coda
library(coda)
mc1 <- mcmc(data=chains[1,])
mc2 <- mcmc(data=chains[2,])
mc3 <- mcmc(data=chains[3,])
mc4 <- mcmc(data=chains[4,])
mcs <- mcmc.list(list(mc1,mc2,mc3,mc4))
gelman.plot(mcs)
```