---
title: "Homework-2023.11.20"
author: "Huiyang Peng"
date: "2023-11-13"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Homework-2023.11.20}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```

# Advanced in R

## 2.1.3 Exercise 4

### Restate

为什么需要用unlist()去将一个列表转化为原子向量？为什么as.vector()没有作用？

### Answer

我查看了vector的文档，在Details中有这样一段，However, when x is of type "list" or "expression", as.vector(x) currently returns the argument x unchanged, unless there is an as.vector method for class(x)。即当x的数据类型是"list"的时候，as.vector()函数的返回值会保持不变。而unlist函数则是Given a list structure x, unlist simplifies it to produce a vector which contains all the atomic components which occur in x，所以unlist是针对list类型的，但as.vector函数没有针对list的设计。

## 2.3.1 Exercise 1

### Restate

dim()函数被作用于向量时会返回什么？

### Answer

向量没有dim这一attribute，所以应该会返回NULL。

```{r}
x <- c(1,2,3)
dim(x)
```

## 2.3.1 Exercise 2

### Restate

如果is.matrix(x)==TRUE，那么is.array(x)会返回什么？

### Answer

matrix是array的一个特殊子类，因此matrix一定是array，所以is.array(x)返回TRUE。

```{r}
m <- matrix(1:4, ncol = 2)
is.array(m)
```

## 2.4.5 Exercise 2

### Restate

as.matrix()被用于有不同类型的列的数据框的时候会做什么？

### Answer

根据文档，The method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column。即如果有numeric/logical/complex之外的类的数据类型就会都转为character。

```{r}
x <- data.frame(a=c(1,2),b=c("a","b"))
as.matrix(x)
```

## 2.4.5 Exercise 3

### Restate

有0行或者0列的数据框吗？

### Answer

都有。

```{r}
A = data.frame(matrix(0, ncol=0, nrow=2))
A
```

```{r}
B = data.frame(matrix(0, ncol=2, nrow=0))
A
```

## 11.1.2 Exercise 2

### Restate

下面这个函数将向量标准化到[0,1]区间里。如何将他应用到数据框的每一列？又该如何将他应用到数据框的每个数值型的列？

```{r}
scale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
```

### Answer

如果希望将他应用到数据框的每一列，那么可以直接使用lapply

```{r}
X <- data.frame(a = c(1,2,3,4), b = c(2,1,4,5))
lapply(X, scale01)
```

如何希望仅仅用到数值型的列上，那么需要用sapply先做选择：

```{r}
Y <- data.frame(a = c(1,2,3,4), b = c("a","b","c","d"))
lapply(Y[sapply(Y, is.numeric)], scale01)
```

## 11.2.5 Exercise 1

### Restate

Use vapply() to:
a) Compute the standard deviation of every column in a numeric data frame.
b) Compute the standard deviation of every numeric column
in a mixed data frame. (Hint: you’ll need to use vapply()
twice.)

用vapply()：
a) 计算一个数值型data.frame中每一列的标准差。
b) 计算一个混合型data.frame中每一个数值型列的标准差。

### Answer

```{r}
# a)
vapply(X, sd, numeric(1))
```

```{r}
# b)
vapply(Y[vapply(Y, is.numeric, logical(1))], sd, numeric(1))
```

# Statistical Computing with R

## Exercise 9.8

### Restate

 (提示：参考Case study中的第一个例子)
 
- 写一个R函数.

- 写一个Rcpp函数.

- 用microbenchmark比较这两个函数的计算时间。

```{r}
library(microbenchmark)
library(Rcpp)
dir_cpp <- './Rcpp/'

source(paste0(dir_cpp,'GibbsR.R'))
sourceCpp(paste0(dir_cpp,'GibbsC.cpp'))
ts <- microbenchmark(gibbR=gibbsR(10, 1, 3, 100,10), gibbC=gibbsC(10, 1, 3, 100,10))
summary(ts)[,c(1,3,5,6)]
```